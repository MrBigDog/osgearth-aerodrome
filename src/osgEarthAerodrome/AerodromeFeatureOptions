/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2014 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_AERODROME_AERODROMEFEATUREOPTIONS
#define OSGEARTH_AERODROME_AERODROMEFEATUREOPTIONS 1

#include <osg/Group>

#include "Common"
#include <osgEarthFeatures/FeatureSource>

namespace osgEarth { namespace Aerodrome
{
    using namespace osgEarth;
    using namespace osgEarth::Features;


    class TextureOptions : public ConfigOptions
    {
    public:
        /** ICAO code attribute name */
        optional<URI>& url() { return _imageURI; }
        const optional<URI>& url() const { return _imageURI; }    

        optional<float>& length() { return _length; }
        const optional<float>& length() const { return _length; }

    public:
        TextureOptions( const ConfigOptions& opt =ConfigOptions() ) :
          ConfigOptions( opt )
        {            
            fromConfig( _conf );
        }

        virtual ~TextureOptions() { }

    public:
        Config getConfig() const {
            Config conf = ConfigOptions::getConfig();
            conf.updateIfSet( "url", _imageURI );
            conf.updateIfSet( "length", _length );  
            return conf;
        }

    protected:
        void mergeConfig( const Config& conf ) {
            ConfigOptions::mergeConfig( conf );
            fromConfig( conf );
        }

    private:
        void fromConfig( const Config& conf ) {
            conf.getIfSet( "url", _imageURI );
            conf.getIfSet<float>( "length", _length );
        }
     
        optional<URI>    _imageURI;
        optional<float> _length;
    };

    class ModelOptions : public ConfigOptions
    {
    public:
        /** ICAO code attribute name */
        optional<URI>& url() { return _imageURI; }
        const optional<URI>& url() const { return _imageURI; }    

        optional<float>& scale() { return _scale; }
        const optional<float>& scale() const { return _scale; }

    public:
        ModelOptions( const ConfigOptions& opt =ConfigOptions() ) :
          _scale(1.0f), ConfigOptions( opt )
        {            
            fromConfig( _conf );
        }

        virtual ~ModelOptions() { }

    public:
        Config getConfig() const {
            Config conf = ConfigOptions::getConfig();
            conf.updateIfSet( "url", _imageURI );
            conf.updateIfSet( "scale", _scale );  
            return conf;
        }

    protected:
        void mergeConfig( const Config& conf ) {
            ConfigOptions::mergeConfig( conf );
            fromConfig( conf );
        }

    private:
        void fromConfig( const Config& conf ) {
            conf.getIfSet( "url", _imageURI );
            conf.getIfSet<float>( "scale", _scale );
        }
     
        optional<URI>    _imageURI;
        optional<float>  _scale;
    };

    /**
     * Options for the Aerodrome features
     */
    class AerodromeFeatureOptions : public ConfigOptions
    {
    public:
        /** ICAO code attribute name */
        optional<std::string>& icaoAttr() { return _icaoAttr; }
        const optional<std::string>& icaoAttr() const { return _icaoAttr; }    

        optional<FeatureSourceOptions>& featureOptions() { return _featureOptions; }
        const optional<FeatureSourceOptions>& featureOptions() const { return _featureOptions; }

        optional<TextureOptions>& textureOptions() { return _textureOptions; }
        const optional<TextureOptions>& textureOptions() const { return _textureOptions; }

        optional<ModelOptions>& modelOptions() { return _modelOptions; }
        const optional<ModelOptions>& modelOptions() const { return _modelOptions; }

    public:
        AerodromeFeatureOptions( const ConfigOptions& opt =ConfigOptions() ) :
          ConfigOptions( opt ),
          _icaoAttr("apt_icao")
        {            
            fromConfig( _conf );
        }

        virtual ~AerodromeFeatureOptions() { }

    public:
        Config getConfig() const {
            Config conf = ConfigOptions::getConfig();
            conf.updateIfSet( "icao_attr", _icaoAttr );
            conf.updateObjIfSet( "features", _featureOptions );
            conf.updateObjIfSet( "texture", _textureOptions );
            conf.updateObjIfSet( "model", _modelOptions );
            return conf;
        }

    protected:
        void mergeConfig( const Config& conf ) {
            ConfigOptions::mergeConfig( conf );
            fromConfig( conf );
        }

    private:
        void fromConfig( const Config& conf ) {
            conf.getIfSet( "icao_attr", _icaoAttr );
            conf.getObjIfSet( "features", _featureOptions );
            conf.getObjIfSet( "texture", _textureOptions );
            conf.getObjIfSet( "model", _modelOptions );
        }
     
        optional<std::string> _icaoAttr;
        optional<FeatureSourceOptions> _featureOptions;
        optional<TextureOptions> _textureOptions;
        optional<ModelOptions> _modelOptions;
    };

} } // namespace osgEarth::Aerodrome

#endif // OSGEARTH_AERODROME_AERODROMEFEATUREOPTIONS
