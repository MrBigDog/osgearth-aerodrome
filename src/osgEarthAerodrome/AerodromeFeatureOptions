/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2014 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_AERODROME_AERODROMEFEATUREOPTIONS
#define OSGEARTH_AERODROME_AERODROMEFEATUREOPTIONS 1

#include <osg/Group>

#include "Common"
#include <osgEarthFeatures/FeatureSource>

namespace osgEarth { namespace Aerodrome
{
    using namespace osgEarth;
    using namespace osgEarth::Features;


    class FeatureSelectorOptions : public ConfigOptions
    {
    public:
        optional<std::string>& attr() { return _attr; }
        const optional<std::string>& attr() const { return _attr; }    

        optional<std::string>& value() { return _value; }
        const optional<std::string>& value() const { return _value; }

    public:
        FeatureSelectorOptions( const ConfigOptions& opt =ConfigOptions() ) :
          ConfigOptions( opt )
        {            
            fromConfig( _conf );
        }

        virtual ~FeatureSelectorOptions() { }

    public:
        Config getConfig() const {
            Config conf = ConfigOptions::getConfig();
            conf.updateIfSet( "attr", _attr );
            conf.updateIfSet( "value", _value );  
            return conf;
        }

    protected:
        void mergeConfig( const Config& conf ) {
            ConfigOptions::mergeConfig( conf );
            fromConfig( conf );
        }

    private:
        void fromConfig( const Config& conf ) {
            conf.getIfSet<std::string>( "attr", _attr );
            conf.getIfSet<std::string>( "value", _value );
        }
     
        optional<std::string>  _attr;
        optional<std::string>  _value;
    };

    class TextureOptions : public ConfigOptions
    {
    public:
        /** ICAO code attribute name */
        optional<URI>& url() { return _imageURI; }
        const optional<URI>& url() const { return _imageURI; }    

        optional<float>& length() { return _length; }
        const optional<float>& length() const { return _length; }

    public:
        TextureOptions( const ConfigOptions& opt =ConfigOptions() ) :
          ConfigOptions( opt )
        {            
            fromConfig( _conf );
        }

        virtual ~TextureOptions() { }

    public:
        Config getConfig() const {
            Config conf = ConfigOptions::getConfig();
            conf.updateIfSet( "url", _imageURI );
            conf.updateIfSet( "length", _length );  
            return conf;
        }

    protected:
        void mergeConfig( const Config& conf ) {
            ConfigOptions::mergeConfig( conf );
            fromConfig( conf );
        }

    private:
        void fromConfig( const Config& conf ) {
            conf.getIfSet( "url", _imageURI );
            conf.getIfSet<float>( "length", _length );
        }
     
        optional<URI>    _imageURI;
        optional<float> _length;
    };

    class ModelOptions : public ConfigOptions
    {
    public:
        /** ICAO code attribute name */
        optional<URI>& url() { return _imageURI; }
        const optional<URI>& url() const { return _imageURI; }    

        optional<float>& scale() { return _scale; }
        const optional<float>& scale() const { return _scale; }

        optional<FeatureSelectorOptions>& selector() { return _selector; }
        const optional<FeatureSelectorOptions>& selector() const { return _selector; }

    public:
        ModelOptions( const ConfigOptions& opt =ConfigOptions() ) :
          _scale(1.0f), ConfigOptions( opt )
        {            
            fromConfig( _conf );
        }

        virtual ~ModelOptions() { }

    public:
        Config getConfig() const {
            Config conf = ConfigOptions::getConfig();
            conf.updateIfSet( "url", _imageURI );
            conf.updateIfSet( "scale", _scale );
            conf.updateObjIfSet( "selector", _selector );
            return conf;
        }

    protected:
        void mergeConfig( const Config& conf ) {
            ConfigOptions::mergeConfig( conf );
            fromConfig( conf );
        }

    private:
        void fromConfig( const Config& conf ) {
            conf.getIfSet( "url", _imageURI );
            conf.getIfSet<float>( "scale", _scale );
            conf.getObjIfSet( "selector", _selector );
        }
     
        optional<URI>                    _imageURI;
        optional<float>                  _scale;
        optional<FeatureSelectorOptions> _selector;
    };

    typedef std::list<class ModelOptions> ModelOptionsSet;

    /**
     * Options for the Aerodrome features
     */
    class AerodromeFeatureOptions : public ConfigOptions
    {
    public:
        /** ICAO code attribute name */
        optional<std::string>& icaoAttr() { return _icaoAttr; }
        const optional<std::string>& icaoAttr() const { return _icaoAttr; }    

        optional<FeatureSourceOptions>& featureOptions() { return _featureOptions; }
        const optional<FeatureSourceOptions>& featureOptions() const { return _featureOptions; }

        optional<TextureOptions>& textureOptions() { return _textureOptions; }
        const optional<TextureOptions>& textureOptions() const { return _textureOptions; }

        //ModelOptionsSet& modelOptions() { return _modelOptions; }
        const ModelOptionsSet& modelOptions() const { return _modelOptions; }

    public:
        AerodromeFeatureOptions( const ConfigOptions& opt =ConfigOptions() ) :
          ConfigOptions( opt ),
          _icaoAttr("apt_icao")
        {            
            fromConfig( _conf );
        }

        virtual ~AerodromeFeatureOptions() { }

    public:
        Config getConfig() const {
            Config conf = ConfigOptions::getConfig();
            conf.updateIfSet( "icao_attr", _icaoAttr );
            conf.updateObjIfSet( "features", _featureOptions );
            conf.updateObjIfSet( "texture", _textureOptions );

            for(ModelOptionsSet::const_iterator i = _modelOptions.begin(); i != _modelOptions.end(); ++i)
                conf.add("model", i->getConfig());

            return conf;
        }

    protected:
        void mergeConfig( const Config& conf ) {
            ConfigOptions::mergeConfig( conf );
            fromConfig( conf );
        }

        void fromConfig( const Config& conf ) {
            conf.getIfSet( "icao_attr", _icaoAttr );
            conf.getObjIfSet( "features", _featureOptions );
            conf.getObjIfSet( "texture", _textureOptions );
            
            ConfigSet models = conf.children("model");
            for (ConfigSet::const_iterator i = models.begin(); i != models.end(); i++)
                _modelOptions.push_back(ModelOptions(*i));
        }

    private:
     
        optional<std::string> _icaoAttr;
        optional<FeatureSourceOptions> _featureOptions;
        optional<TextureOptions> _textureOptions;
        ModelOptionsSet _modelOptions;
    };

    typedef std::list<class AerodromeFeatureOptions> AerodromeOptionsSet;

    /**
     * Options for the Aerodrome features
     */
    class BoundaryFeatureOptions : public AerodromeFeatureOptions
    {
    public:
        /** ICAO code attribute name */
        optional<std::string>& elevationAttr() { return _elevationAttr; }
        const optional<std::string>& elevationAttr() const { return _elevationAttr; }    

    public:
        BoundaryFeatureOptions( const ConfigOptions& opt =ConfigOptions() ) :
          AerodromeFeatureOptions( opt )
        {            
            fromConfig( _conf );
        }

        virtual ~BoundaryFeatureOptions() { }

    public:
        Config getConfig() const {
            Config conf = AerodromeFeatureOptions::getConfig();
            conf.updateIfSet( "elevation_attr", _elevationAttr );

            return conf;
        }

    protected:
        void mergeConfig( const Config& conf ) {
            AerodromeFeatureOptions::mergeConfig( conf );
            fromConfig( conf );
        }

        void fromConfig( const Config& conf ) {
            AerodromeFeatureOptions::fromConfig(conf);

            conf.getIfSet( "elevation_attr", _elevationAttr );
        }

    private:
     
        optional<std::string> _elevationAttr;
    };

    typedef std::list<class BoundaryFeatureOptions> BoundaryOptionsSet;

} } // namespace osgEarth::Aerodrome

#endif // OSGEARTH_AERODROME_AERODROMEFEATUREOPTIONS
